#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass kuthesis
\begin_preamble
%%\usepackage{latexsym}
\usepackage{graphicx}

%%\usepackage{psfig}
%%\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{ragged2e}
\RaggedRight
%\setlength{\parindent}{1.5 em}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}

\usepackage{fvextra}
\usepackage{pstricks}
\usepackage{pstricks-add}
\usepackage{epsfig}
\usepackage{pst-grad} % For gradients
\usepackage{pst-plot} % For axes
\usepackage[space]{grffile} % For spaces in paths
\usepackage{etoolbox} % For spaces in paths
\makeatletter % For spaces in paths
\patchcmd\Gread@eps{\@inputcheck#1 }{\@inputcheck"#1"\relax}{}{}
\makeatother
\usepackage{auto-pst-pdf}

\usepackage{nccmath}
\usepackage{setspace}
\end_preamble
\use_default_options false
\master ../thesis-ku.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "Times New Roman"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=none,xleftmargin=2pt,stepnumber=1,numbers=left,numbersep=5pt,numberstyle={\ttfamily\tiny\color[gray]{0.3}},belowcaptionskip={\bigskipamount},captionpos=b,escapeinside={*'}{'*},language=Haskell,tabsize=2,emphstyle={\bf},commentstyle={\it},stringstyle={\mdseries\rmfamily},showspaces=false,keywordstyle={\bfseries\rmfamily},columns=flexible,basicstyle={\small\sffamily},showstringspaces=false,morecomment={[l]\%}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Extending Remote Lenses
\end_layout

\begin_layout Standard
This chapter explicitly will deal with a compare and contrast to the Extended
 Lenses chapter, along with any additional information that was out of place
 in the Remote Monad Chapter.
 The end goal is a reasonable intuition if Remote Lenses are indeed Lenses.
 One having paid careful mind in the detailing of implementation and theory
 discussed about the Remote Lenses, should have come to a question about
 the exact degree of resemblance that these structures have to their locally
 designed counterparts.
 In fact, keeping the methods of creating a total lens structure, a way
 to show the closeness between Local Lenses and Remote Lenses would be to
 attempt expressing their remote nature in the style of the local abstractions.
 Now we will start with attempting to shape the structure of RemoteView
 and RemoteSet into a data structure.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{spacing}{1}
\end_layout

\begin_layout Plain Layout


\backslash
begin{code}[baselinestretch = 1,xleftmargin=5mm,xrightmargin=5mm,breaklines,brea
kanywhere=false,breakafter={>}]
\end_layout

\begin_layout Plain Layout

data RemoteLens a b = RemoteLens {
\end_layout

\begin_layout Plain Layout

    remote_view ::  (FromJSON b) => (String -> String) -> (RemoteValue a)
 -> (RemoteMonad b)
\end_layout

\begin_layout Plain Layout

    , remote_set :: (String -> String) -> String -> (RemoteValue a) -> RemoteMon
ad (RemoteValue a)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

applyview :: FromJSON b => RemoteLens2 a b -> (String -> String) -> RemoteValue
 a -> RemoteMonad b 
\end_layout

\begin_layout Plain Layout

applyview (RemoteLens2 remote_view remote_set) = remote_view
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

applyset :: RemoteLens2 a b -> (String -> String) -> String -> RemoteValue
 a -> RemoteMonad (RemoteValue a) 
\end_layout

\begin_layout Plain Layout

applyset (RemoteLens2 remote_view remote_set) = remote_set
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a_Lens :: RemoteLens a b
\end_layout

\begin_layout Plain Layout

a_Lens = RemoteLens {
\end_layout

\begin_layout Plain Layout

    remote_view = RemoteView
\end_layout

\begin_layout Plain Layout

    , remote_set = RemoteSet}
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whilst the nature of being able to neatly wrap the generalized Remote Lens
 commands together is easily implemented, this immediately approach doesn't
 come close to the meaning held in the local variation in Chapter 3.
 The meaning of wrapping the View and Set together in a Local Lens, is to
 wrap together the means of accessing a specific focus.
 In this case, we have wrapped together a general RemoteView and RemoteSet,
 that can be specialized to access anywhere in the larger Remote Structure.
 Essentially this form of abstraction only complicates the use of the original
 commands, while pointlessly obfuscating the underlying ease of use that
 the composability of the pseudo-accessor functions were supposed to provide.
\end_layout

\begin_layout Standard
Not to easily give up hope just yet that an equivalent method exists, the
 next significant attempt is to instantiate a far less general Remote Lens
 data type and the way to do this is to start talking about the primary
 example from Chapter 4.
 The abstraction will be directly over the accessor methods, much in the
 similar way that the abstractions are attempted on a per element basis
 in normal automatic generation of Local Lens constructions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{spacing}{1}
\end_layout

\begin_layout Plain Layout


\backslash
begin{code}[baselinestretch = 1,xleftmargin=5mm,xrightmargin=5mm,breaklines,brea
kanywhere=false,breakafter={>}]
\end_layout

\begin_layout Plain Layout

data RL_ObjectA  = RL_ObjectA {
\end_layout

\begin_layout Plain Layout

    rl_address :: String -> String
\end_layout

\begin_layout Plain Layout

    , rl_street :: String -> String
\end_layout

\begin_layout Plain Layout

    , rl_city :: String -> String
\end_layout

\begin_layout Plain Layout

    , rl_name :: String -> String
\end_layout

\begin_layout Plain Layout

    , rl_age :: String -> String}
\end_layout

\begin_layout Plain Layout

    deriving (Show)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a_Object :: RL_ObjectA a_Object = RL_ObjectA {
\end_layout

\begin_layout Plain Layout

    rl_address = address
\end_layout

\begin_layout Plain Layout

    , rl_street = street
\end_layout

\begin_layout Plain Layout

    , rl_city = city
\end_layout

\begin_layout Plain Layout

    , rl_name = name
\end_layout

\begin_layout Plain Layout

    , rl_age = age}
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

This doesn't provide anything but a formalization of the ways that Remote
 Lenses were already being handled.
 Which surprisingly, only adds unnecessary bulk to the already clear methods
 of invoking the remote calls.
 The following code shows this specialization does maintain the ability
 to write generalized accessors, that would act on any Remote Lens Object
 that was properly instantiated.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{spacing}{1}
\end_layout

\begin_layout Plain Layout


\backslash
begin{code}[baselinestretch = 1,xleftmargin=5mm,xrightmargin=5mm,breaklines,brea
kanywhere=false,breakafter={>}]
\end_layout

\begin_layout Plain Layout

remote_view_name :: FromJSON b => RL_ObjectA -> RemoteValue a -> RemoteMonad
 b
\end_layout

\begin_layout Plain Layout

remote_view_name object newperson = RemoteView (rl_name object) newperson
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

remote_set_name :: RL_ObjectA -> String -> RemoteValue a -> RemoteMonad
 b
\end_layout

\begin_layout Plain Layout

remote_set_name object item newperson = RemoteView (rl_name object) item
 newperson
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If keeping this line of attempts to specialize, then another perspective
 would be to take the valid alternative construction approach from Chapter
 3 to it's full conclusion with this specific case in Remote Lenses.
 Rather than one specializing the accessors, providing them bundled together
 just like A-lens will allow for a more safe and clear means of using these
 commands.
 In the provided implemenation below, the first introduced method is now
 having it's RemoteView and RemoteSet preinstantiated with the focus of
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{name}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{spacing}{1}
\end_layout

\begin_layout Plain Layout


\backslash
begin{code}[baselinestretch = 1,xleftmargin=5mm,xrightmargin=5mm,breaklines,brea
kanywhere=false,breakafter={>}]
\end_layout

\begin_layout Plain Layout

data RemoteLens a b = RemoteLens {
\end_layout

\begin_layout Plain Layout

    remote_view :: FromJSON b => (RemoteValue a) -> (RemoteMonad b)
\end_layout

\begin_layout Plain Layout

    , remote_set :: String -> (RemoteValue a) -> RemoteMonad (RemoteValue
 a)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

applyview :: FromJSON b => RemoteLens a b -> RemoteValue a -> RemoteMonad
 b
\end_layout

\begin_layout Plain Layout

applyview (RemoteLens2 remote_view remote_set) = remote_view
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

applyset :: RemoteLens a b -> String -> RemoteValue a -> RemoteMonad (RemoteValu
e a)
\end_layout

\begin_layout Plain Layout

applyset (RemoteLens2 remote_view remote_set) = remote_set
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a_Lens :: RemoteLens a b a_Lens = RemoteLens {
\end_layout

\begin_layout Plain Layout

    remote_view = RemoteView name
\end_layout

\begin_layout Plain Layout

    , remote_set = RemoteSet name}
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\begin_layout Plain Layout


\backslash
end{spacing}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\end_body
\end_document
