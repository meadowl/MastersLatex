#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass kuthesis
\begin_preamble
%%\usepackage{latexsym}
\usepackage{graphicx}

%%\usepackage{psfig}
%%\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{ragged2e}
\RaggedRight
%\setlength{\parindent}{1.5 em}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}
\end_preamble
\use_default_options false
\master ../thesis-ku.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "Times New Roman"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=none,xleftmargin=2pt,stepnumber=1,numbers=left,numbersep=5pt,numberstyle={\ttfamily\tiny\color[gray]{0.3}},belowcaptionskip={\bigskipamount},captionpos=b,escapeinside={*'}{'*},language=Haskell,tabsize=2,emphstyle={\bf},commentstyle={\it},stringstyle={\mdseries\rmfamily},showspaces=false,keywordstyle={\bfseries\rmfamily},columns=flexible,basicstyle={\small\sffamily},showstringspaces=false,morecomment={[l]\%}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
The origin of this manuscript began with looking for overall abstractions
 between remote object systems and being curious as to seeing if adding
 an ordered lens-like structure was possible between multiple systems.
 Even if the abstraction is nothing more than a wrapper or boilerplate for
 existing code, it sparked curiosity if these remote systems could stimulate
 or in fact provide the simplicity of lenses to an end user.
 And that these abstractions were representable of total systems in existence,
 due to the popularity of classical lenses.
 It was discovered that online server applications attempt to bring this
 boilerplate into their own code with different levels of effectiveness
 across their own systems.
\end_layout

\begin_layout Standard
This led to some initial questions and concerns, mainly what a lens is,
 what a lens is in a programming language — specifically Haskell, and what
 are the existing standards for what constitutes the different categories
 of lenses that exist in the broad community.
\end_layout

\begin_layout Standard
Keeping in mind that Lenses are about solving a bijective interaction with
 a data structure, as so little as to provide convenience to the end user
 and as far to provide many layers of type safety.
 Most commonly in the functional community lenses are abstractions that
 are popular to provide an object-oriented accessor notation to an object’s
 elements.
 In the sense that the functions that wrap data into structures are able
 to be acted on by functions that unwrap or re-wrap data in a convenient
 way.
 There are extensional ideas that relate to this such as Traversable structures
 and those should be representable as well.
 But that is not the primary focus of this research, although in the case
 of Remote Monad, the Traversable is very much implementable abet with some
 extra efforts.
\end_layout

\begin_layout Standard
Lenses are in briefest summary a mathematical tool to solve the bidirectional
 transformations problem.
 They came as an expansion to the mostly solved bijective dictionary space
 and an attempt to further expand out the work with new levels of abstractions.
 Every lens has a set and a get function that it bundles together, and are
 modeled after object-class accessors.
 To accomplish the goal of retrieving or mutating values inside of those
 kinds of objects.
 As to what the community considers a well-behaved lens, this in itself
 can be varied and ends up becoming unclear based on who’s implementation
 and rationalization one reads on.
 Much like much of computer science terms end up thrown around interchangeably,
 meanings are lost and altered for established words, and so therefore it
 becomes important to establish what each body of work considers to be a
 lens and a well-behaved lens.
\end_layout

\begin_layout Standard
For starters what separates well-behaved from not? A well-behaved function
 follows what are generally expected rules and results that the average
 user might expect.
 And a function that is not well-behaved will possibly posses unexpected
 behaviors that the user does not intend to occur.
 A clever way to imagine this is to imagine the standards in place for the
 C++ compiler.
 There are well-behaved and expected results if one were to define a simple
 addition function.
 However, there are no defined results as to what should happen if one's
 main function does not have a return statement embedded at the end.
 So in this way a well-behaved lens has some expected behaviors that will
 always hold true if it follows a community's prescribed expectations.
 But unfortunately, the manual itself is ill-defined based on the source
 that one prescribes, therefore it is important that in this body of work
 the manual for a well-behaved lens is included.
 So that it becomes possible to judge in this body of work if the lens fits
 the established expectations with its behaviors.
 And ultimately anything that is not defined should be disregarded in the
 same way that one might disregard the C++ compilers handling of no return
 statement in main.
 This manuscript is ultimately concerned with defined behaviors as they
 relate to defined expectations.
\end_layout

\begin_layout Standard
Leading to the main body of this work which will be an exploration and attempt
 to quantitatively define Remote Lenses, and unique differences that one
 can describe when holding them up to the light in comparison to classical
 Local Lenses.
\end_layout

\begin_layout Standard
There are several types of lenses that bridge the gap between remote and
 local interactions already in existence, to varying degrees of depth of
 implementation.
 As well as what the focus of those implementations were in the broader
 scheme.
 From the broad categories of c-lenses to the category of d-lenses, 
\begin_inset CommandInset citation
LatexCommand citet
key "Johnson2013"
literal "false"

\end_inset

, using the concepts of opfibrations to encapsulate the nature of transition
 information between a system and a database.
 The previous work, derives the motivation from the database systems such
 as SQL and the manipulation of table or record information, i.e.
 the original derivation of the c-lens from the categorical notion of Grothendie
ck opfibration for a solution to the view update problem for functorial
 update processes, 
\begin_inset CommandInset citation
LatexCommand citet
key "Johnson2011"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Specific implementations that directly reference how a host can only see
 a certain amount of information from the client side's database system,
 with a goal that both must maintain a consistently updated view no matter
 the views or set that are executed, 
\begin_inset CommandInset citation
LatexCommand citet
key "Ahman2014"
literal "false"

\end_inset

.
 Much of the specifics in theory has grown from the typical database relationshi
p from SQL and other table based services, and the constructed ideas are
 tailored to concepts display in works like 
\begin_inset CommandInset citation
LatexCommand citet
key "Bohannon2006"
literal "false"

\end_inset

.
 Several works are representative of these direct methods and their specific
 heritage in database problems with source-to-target and target-to-source
 transformations, 
\begin_inset CommandInset citation
LatexCommand citet
key "Fuxman2006"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
From the category of automatic lens generators and parsers, most notably
 Boomerang a bidirectional programming language for textual data, 
\begin_inset CommandInset citation
LatexCommand citet
key "Barbosa2010"
literal "false"

\end_inset

.
 With further development into automatic subsets of the textual lenses explored
 further in the Optician implementation of the Boomerang system, 
\begin_inset CommandInset citation
LatexCommand citet
key "Miltner2017"
literal "false"

\end_inset

.
 While there is some escape to other parts of a Linux system in these two
 tools, it is important to note that they remain limited to the express
 manipulation and editing of strings even if directed to say a configuration
 file.
 The automatic formation of lenses has been limited to closed systems where
 the understanding of the underlying systems, in this case strings, are
 fully understood.
 
\end_layout

\begin_layout Standard
For a fair clarification, 
\begin_inset CommandInset citation
LatexCommand citet
key "Foster2007"
literal "false"

\end_inset

, this field has been strictly derived from the premise of database systems,
 with even this primary source document having constrained itself to a strict
 representation in the fundamentals.
 Which is why there is still open space for sudo-implementations of lenses
 that haven't received much coverage if any in literature, perhaps because
 they break from all of the much higher level concepts and exert effort
 in the more rudimentary space of custom constructed DSLs.
 A DSL that is built over existing systems, not from the ground up with
 an intention of being able to represent much deeper concepts.
 It is a focus on practical designing patterns that are concerned with construct
ion in the execution space.
 Since one doesn't need more than an understanding of the well-behaved lens
 laws to be able to put them into application for remote and local systems.
 Additionally, DSLs already have their own unique sub-field in the lensing
 community with respect to the bidirectional transformation problem 
\begin_inset CommandInset citation
LatexCommand citet
key "Czarnecki2009"
literal "false"

\end_inset

.
 This topic focuses on the API advancements provided by the remote monad
 design pattern for remote calls to external systems for the purposes of
 Remote Procedure Calls that have their commands executed remotely before
 returned locally .
 The Remote Lensing is in the same vein as the typical database lensing
 problem, it distinguishes itself by being primarily focused on Remote Procedure
 Calls rather than the typical database problems.
 This system is not an attempt at the 
\end_layout

\end_body
\end_document
