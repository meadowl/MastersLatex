#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass kuthesis
\begin_preamble
%%\usepackage{latexsym}
\usepackage{graphicx}

%%\usepackage{psfig}
%%\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{ragged2e}
\RaggedRight
%\setlength{\parindent}{1.5 em}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}
\usepackage{haskell}
\end_preamble
\use_default_options false
\master ../thesis-ku.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=none,xleftmargin=2pt,stepnumber=1,numbers=left,numbersep=5pt,numberstyle={\ttfamily\tiny\color[gray]{0.3}},belowcaptionskip={\bigskipamount},captionpos=b,escapeinside={*'}{'*},language=Haskell,tabsize=2,emphstyle={\bf},commentstyle={\it},stringstyle={\mdseries\rmfamily},showspaces=false,keywordstyle={\bfseries\rmfamily},columns=flexible,basicstyle={\small\sffamily},showstringspaces=false,morecomment={[l]\%}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The Haskell Lens
\end_layout

\begin_layout Standard
Lenses are restudy of the old bidirectional transformations (bx) problem
 that was already solved through existing dictionary and record systems,
 but their variation to this approach has been the subject of much study
 in the attempts to simply for the end user the ways that they can focus
 in on the individual parts of structures.
\end_layout

\begin_layout Standard
Important note, most definitions have the direction established.
 i.e.
 where one is going.
 So only arguments are the structure itself in view case, with just structure
 and item in set case.
 Which implicates that the overall pattern-matching system which is the
 individually implemented lens for each focus in a structure, has been embedded
 before the configuration of 
\emph on
Set
\emph default
 and 
\emph on
View
\emph default
 respectively in its descriptive rules.
 In practicality the lens is an active and changing argument that the convention
al programmer sets themselves when they are establishing where they'd like
 to mutate a structure.
 Depending on the source, it is perfectly possible that the lens laws themselves
 are defined with that extra argument since including it in the hard coding
 is so common place.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{gather*}
Set\;w\;(View\;w)\;=\;id\\
View\;(Set\;w\;p)\;=\;p\\
Set(Set(w\;p)\;p^{\prime}\;=\;Set(w\;p^{\prime})
\end{gather*}

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Lens Laws
\begin_inset CommandInset label
LatexCommand label
name "fig:Lens Laws"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
Set-View, View-Set are well-behaved.
\end_layout

\begin_layout Plain Layout
\noindent
\align center
Set-Set is very well-behaved.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The structure is so general, polymorphic that we need to establish laws
 that form what lenses are, and what rules that they should follow in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Lens Laws"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This is important since there are lenses that do not follow any strict
 rules and arbitrarily apply bidirectional transformations in ways that
 aren't consistent.
 A prime example would be the implementation of partial functions such that
 the View-Set rule holds but the Set-View doesn't and vise-a-versa for Set-View
 and View-Set respectively.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename LensDiagram.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Lens Diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:Lens Diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is a basic idea of what a simplistic lens accomplishes in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Lens Diagram"
plural "false"
caps "false"
noprefix "false"

\end_inset

, by providing a means to pattern match internally the ability to navigate
 withing a structure and even its substructures are possible.
 As long as the substructure also has been formed in away for pattern matching
 to also work on it.
 This creates a composability of the lenses so that it becomes possible
 to find a focus even if it is nested two or more structures deep.
 Allowing for viewing or setting that focus, depending on the wish of a
 given programmer.
 Essentially embedding a lens friendly structure into a larger one, doesn't
 get rid of the ability to lens into it.
 Provided that the larger structure also has maintained a means to focus
 onto that substructure with it's own lens.
 
\end_layout

\begin_layout Standard
There are some basic Haskell types as well as examples that show that the
 idea of lenses applies to many sorts of structures in the programming world,
 including modifications or inspections of two-tuple structures as displayed
 in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Elementary-Haskell-Lens"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{code}
\end_layout

\begin_layout Plain Layout

view :: w -> p
\end_layout

\begin_layout Plain Layout

set :: w -> p -> w
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

view_a :: (a,b) -> a
\end_layout

\begin_layout Plain Layout

view_a (x,y) = x
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

set_a :: (a,b) -> a -> (a,b)
\end_layout

\begin_layout Plain Layout

set_a (x,y) x' = (x',y)
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Elementary Haskell Lens
\begin_inset CommandInset label
LatexCommand label
name "fig:Elementary-Haskell-Lens"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In these sorts of cases, the general idea of pattern matching to obtain
 results is explicit and summarized inside of the code itself.
 However, the lens in which to focus on a specific element of the two-tuple
 is implied from the direct call to the pattern matching system provided
 by Haskell's compiler.
 This holds true for both view_a and set_a, where the inspection of the
 two-tuple is enough to view or set the contents of the structures respectively.
\end_layout

\begin_layout Standard
Now to explain further, the ideas should be given some space in what a typical
 lens is when locally implemented, since it is fine to talk about the wide
 variety that might be associated with injection and projection rules in
 homotopy type theory.
 It also is noted here that the wider categories or attempts of abstraction
 to lens will also be avoided since they aren't relevant to the contents
 of the papers which includes generalized discussions on asymmetric lenses,
 bimorphic lenses, and likely whatever else has been proposed in the community
 at this point and time.
 And rather than make any bold claims about polymorphic lenses, topics will
 be restricted to monomorphic occurrences instead.
\end_layout

\end_body
\end_document
