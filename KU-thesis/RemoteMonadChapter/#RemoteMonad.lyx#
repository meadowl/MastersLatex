#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass kuthesis
\begin_preamble
%%\usepackage{latexsym}
\usepackage{graphicx}

%%\usepackage{psfig}
%%\usepackage{color}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{ragged2e}
\RaggedRight
%\setlength{\parindent}{1.5 em}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}
\usepackage{haskell}
\end_preamble
\use_default_options false
\master ../thesis-ku.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=none,xleftmargin=2pt,stepnumber=1,numbers=left,numbersep=5pt,numberstyle={\ttfamily\tiny\color[gray]{0.3}},belowcaptionskip={\bigskipamount},captionpos=b,escapeinside={*'}{'*},language=Haskell,tabsize=2,emphstyle={\bf},commentstyle={\it},stringstyle={\mdseries\rmfamily},showspaces=false,keywordstyle={\bfseries\rmfamily},columns=flexible,basicstyle={\small\sffamily},showstringspaces=false,morecomment={[l]\%}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Remote Monad
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{chapterabstract}
\end_layout

\begin_layout Plain Layout

Initial draft to describe and write about the remote monad and the remote
 lens.
\end_layout

\begin_layout Plain Layout


\backslash
end{chapterabstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As has been established in the earlier chapter, covering the mathematical
 background and the historical Haskell programming context, this primary
 article will show both an introduction to remote lenses as well as their
 implementation with the remote monad.
 As described the two primary components of both programmatic and mathematical
 lenses are the 
\emph on
Set
\emph default
 and 
\emph on
View 
\emph default
which produce as a result of applying them both at the same time a command
 referenced as 
\emph on
Over
\emph default
.
 Which now allows us to describe a variation that copies on the structure
 and intent of these operators over a remote connection between a client
 and a host device, the host running Haskell and the client running some
 other language.
 This variation which is the main subject of study of this paper will be
 referred to as the 
\emph on
Remote Lens
\emph default
 and will be fleshed out starting now and until the end of this manuscript.
\end_layout

\begin_layout Standard
To start defining the individual components of 
\emph on
Remote Lenses
\emph default
, we must begin with an abstract type definition which will prove useful
 in guiding through more concrete implementations that will be brought forward
 later on.
 They are provided below.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{haskell*}
\end_layout

\begin_layout Plain Layout

RemoteView &::& (String 
\backslash
to String) 
\backslash
to (Wrapped a) 
\backslash
to (ReturnType b)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

RemoteSet &::& (String 
\backslash
to String) 
\backslash
to String 
\backslash
to (Wrapped a) 
\backslash
to ReturnType (Wrapped a)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

RemoteOver &::& (String 
\backslash
to String) 
\backslash
to (t 
\backslash
to a) 
\backslash
to (Wrapped a) 
\backslash
to ReturnType (Wrapped a)
\end_layout

\begin_layout Plain Layout


\backslash
end{haskell*}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The essentials of what is required is aptly similar to the definitions seen
 in the elementary Prelude construction of Haskell lenses.
 With that in mind, the first argument typically taken by any lens operator
 is a function that will access a deep rooted parameter inside of a structure.
 And the Remote Lens variant accomplishes the same with an abstraction of
 the Remote Object's nested fields.
 Another shared argument is the structure that will be accessed by the lens
 operator.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\end_layout

\begin_layout Plain Layout


\backslash
begin{haskell*}
\end_layout

\begin_layout Plain Layout

RemoteView &::& (FromJSON b) 
\backslash
Rightarrow (String 
\backslash
to String) 
\backslash
to (RemoteValue a) 
\backslash
to (RemoteMonad b)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

RemoteSet &::& (String 
\backslash
to String) 
\backslash
to String 
\backslash
to (RemoteValue a) 
\backslash
to RemoteMonad (RemoteValue a)
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

RemoteOver &::&  
\backslash
hsbody{%(FromJSON t, Show a) 
\backslash
Rightarrow (String 
\backslash
to String) 
\backslash
to (t 
\backslash
to a) 
\backslash
to (RemoteValue a) 
\backslash
to RemoteMonad (RemoteValue a)
\end_layout

\begin_layout Plain Layout


\backslash
end{haskell*}
\end_layout

\begin_layout Plain Layout

%
\end_layout

\end_inset


\end_layout

\begin_layout Standard
view2 :: (FromJSON b) => (String -> String) -> (RemoteValue a) -> (RemoteMonad
 b) 
\end_layout

\begin_layout Standard
set2 :: (String -> String) -> String -> (RemoteValue a) -> RemoteMonad (RemoteVa
lue a) 
\end_layout

\begin_layout Standard
over2 :: (FromJSON t, Show a) => (String -> String) -> (t -> a) -> (RemoteValue
 a) -> RemoteMonad (RemoteValue a)
\end_layout

\begin_layout Standard
These are the types for the set of functions that seek to emulate the Get
 and Put laws that lenses experience.
 And show that although they do not share the same internal structure at
 their locally implemented counterparts, that they will share a similar
 external behavior.
\end_layout

\begin_layout Standard
Such that as in the abstract syntax that: 
\end_layout

\begin_layout Standard
Set2 ( View2 (s ) s ) = s 
\end_layout

\begin_layout Standard
Set2( Set2( a v) s ) = Put( a s) 
\end_layout

\begin_layout Standard
View2( Set2( a s) ) = a 
\end_layout

\begin_layout Standard
Is a similar result, however it is worth noting, that due to the fact that
 we are dealing with a remote connection that the connection must be passed
 around – in addition to the object you want to manipulate, where inside
 the object you wish to lens to, and a value if using the Put function.
\end_layout

\begin_layout Standard
Now, one more important thing to note, is while in Haskell you normally
 are manipulating and creating new objects every time you run a function
 or assign it to a value.
 When manipulating Javascript, you are never creating a new object on the
 other side.
 So, any code you’d want to write with these methods on the Haskell-side,
 would need to keep in mind that you never are dealing with a fresh object.
 The connection will always make sure you are pointing to the one and only
 original Javascript object you are trying to manipulate.
\end_layout

\begin_layout Standard
A key distinction on the improvements is that this removes any sort of backend
 coding, where the user is directly manipulating the delicate remote monad
 commands.
 And instead has a predefined way of accessing, editing, and setting values
 with minimal contact to the ideas and command structure beneath.
\end_layout

\begin_layout Standard
So much like lenses were used to re-solve the local dictionary problem.
\end_layout

\begin_layout Standard
Remote lenses here are used to re-solve the remote dictionary problem.
\end_layout

\begin_layout Standard
And this is a clear method that shows how it can be solved.
\end_layout

\begin_layout Standard
You get abstraction and type safety on every component of the command, and
 modularity that clearly expresses your intent to the reader of your code.
\end_layout

\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
With basic syntactical sugar, with view2 as ^.
 And composition of remote lens fields as >>> … you get a clear expression
 that shows to anyone else on your coding team what you were doing.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Haskell"
inline false
status open

\begin_layout Plain Layout

f :: Double <- person ^.
 nest >>> nest2 >>> extra3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
f :: Double <- person ^.
 nest >>> nest2 >>> extra3
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{code}
\end_layout

\begin_layout Plain Layout

-- This is visible in the paper and to the Haskell implementation.
\end_layout

\begin_layout Plain Layout

f :: Double <- person ^.
 nest >>> nest2 >>> extra3
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\begin_layout Plain Layout


\backslash
begin{lstlisting}
\end_layout

\begin_layout Plain Layout

f :: Double <- person ^.
 nest >>> nest2 >>> extra3
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where for the remote-object of person, I am accessing 2 layers into it’s
 fields to retrieve a double value from extra3.
\end_layout

\begin_layout Standard
The normal syntax for this would be represented as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Set_{2}\left(View_{2}\left(s\right)\:s\right)=s
\]

\end_inset


\end_layout

\begin_layout Standard
view2 (extra3(nest2(nest))) person
\end_layout

\begin_layout Standard
Which expands out to in the weeds as: —
\end_layout

\begin_layout Standard
g <- constructor $ JavaScript $ pack $ (extra3(nest2(nest))) (var_text person)
 procedure $ var g 
\end_layout

\begin_layout Standard
Repeat this for Set, Over, and for the examples of Lens Laws? (Yes) 
\end_layout

\end_body
\end_document
