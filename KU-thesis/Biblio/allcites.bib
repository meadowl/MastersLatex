% Encoding: UTF-8

@InProceedings{Czarnecki2009,
  author    = {Czarnecki, Krzysztof and Foster, Nate and Hu, Zhenjiang and Lämmel, Ralf and Schürr, Andy and Terwilliger, James},
  booktitle = {Theory and Practice of Model Transformations},
  title     = {Bidirectional Transformations: A Cross-Discipline Perspective},
  year      = {2009},
  month     = {06},
  pages     = {260-283},
  publisher = {Springer Berlin Heidelberg},
  volume    = {5563},
  doi       = {10.1007/978-3-642-02408-5_19},
  isbn      = {978-3-642-02407-8},
}

@Article{Ahman2014,
  author    = {Danel Ahman and Tarmo Uustalu},
  journal   = {Electronic Notes in Theoretical Computer Science},
  title     = {Coalgebraic Update Lenses},
  year      = {2014},
  issn      = {1571-0661},
  month     = {oct},
  note      = {Proceedings of the 30th Conference on the Mathematical Foundations of Programming Semantics (MFPS XXX)},
  pages     = {25-48},
  volume    = {308},
  abstract  = {Lenses are mathematical structures used in the context of bidirectional transformations. In this paper, we introduce update lenses as a refinement of ordinary (asymmetric) lenses in which we distinguish between views and updates. In addition to the set of views, there is a monoid of updates and an action of the monoid on the set of views. Decoupling updates from views allows for other ways of changing the source than just merging a view into the source. We also consider a yet finer dependently typed version of update lenses. We give a number of characterizations of update lenses in terms of bialgebras and coalgebras, including analogs to O'Connor's coalgebraic and Johnson, Rosebrugh and Wood's algebraic characterizations of ordinary lenses. We consider conversion of views and updates, a tensor product of update lenses and composition of update lenses.},
  doi       = {https://doi.org/10.1016/j.entcs.2014.10.003},
  keywords  = {lenses, comonads, monads, coalgebras, algebras, bialgebras, distributive laws, liftings, monoid acts, directed containers},
  publisher = {Elsevier {BV}},
  url       = {https://www.sciencedirect.com/science/article/pii/S157106611400070X},
}

@Article{Miltner2017,
  author     = {Miltner, Anders and Fisher, Kathleen and Pierce, Benjamin C. and Walker, David and Zdancewic, Steve},
  journal    = {Proc. ACM Program. Lang.},
  title      = {Synthesizing Bijective Lenses},
  year       = {2017},
  month      = dec,
  number     = {POPL},
  pages      = {1--30},
  volume     = {2},
  abstract   = {Bidirectional transformations between different data representations occur frequently in modern software systems. They appear as serializers and deserializers, as parsers and pretty printers, as database views and view updaters, and as a multitude of different kinds of ad hoc data converters. Manually building bidirectional transformations---by writing two separate functions that are intended to be inverses---is tedious and error prone. A better approach is to use a domain-specific language in which both directions can be written as a single expression. However, these domain-specific languages can be difficult to program in, requiring programmers to manage fiddly details while working in a complex type system. We present an alternative approach. Instead of coding transformations manually, we synthesize them from declarative format descriptions and examples. Specifically, we present Optician, a tool for type-directed synthesis of bijective string transformers. The inputs to Optician are a pair of ordinary regular expressions representing two data formats and a few concrete examples for disambiguation. The output is a well-typed program in Boomerang (a bidirectional language based on the theory of lenses). The main technical challenge involves navigating the vast program search space efficiently. In particular, and unlike most prior work on type-directed synthesis, our system operates in the context of a language with a rich equivalence relation on types (the theory of regular expressions). Consequently, program synthesis requires search in two dimensions: First, our synthesis algorithm must find a pair of "syntactically compatible types," and second, using the structure of those types, it must find a type- and example-compliant term. Our key insight is that it is possible to reduce the size of this search space without losing any computational power by defining a new language of lenses designed specifically for synthesis. The new language is free from arbitrary function composition and operates only over types and terms in a new disjunctive normal form. We prove (1) our new language is just as powerful as a more natural, compositional, and declarative language and (2) our synthesis algorithm is sound and complete with respect to the new language. We also demonstrate empirically that our new language changes the synthesis problem from one that admits intractable solutions to one that admits highly efficient solutions, able to synthesize intricate lenses between complex file formats in seconds. We evaluate Optician on a benchmark suite of 39 examples that includes both microbenchmarks and realistic examples derived from other data management systems including Flash Fill, a tool for synthesizing string transformations in spreadsheets, and Augeas, a tool for bidirectional processing of Linux system configuration files.},
  address    = {New York, NY, USA},
  articleno  = {1},
  doi        = {10.1145/3158089},
  issue_date = {January 2018},
  keywords   = {Type-Directed Synthesis, Type Systems, Bidirectional Programming, Program Synthesis},
  numpages   = {30},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/3158089},
}

@Article{Johnson2013,
  author    = {Johnson, Michael and Rosebrugh, Robert},
  journal   = {Electronic Communications of the EASST},
  title     = {Delta Lenses and Opfibrations},
  year      = {2013},
  pages     = {Volume 57: Bidirectional Transformations 2013},
  volume    = {57},
  doi       = {http://dx.doi.org/10.14279/tuj.eceasst.57.875},
  language  = {en},
  publisher = {European Association of Software Science and Technology},
}

@Article{Johnson2011,
  author    = {Johnson, Michael and Rosebrugh, Robert and Wood, Richard J},
  journal   = {Mathematical Structures in Computer Science},
  title     = {Lenses, fibrations and universal translations},
  year      = {2011},
  month     = {may},
  number    = {1},
  pages     = {25},
  volume    = {22},
  doi       = {10.1017/s0960129511000442},
  publisher = {Cambridge University Press},
}

@Article{Barbosa2010,
  author     = {Barbosa, Davi M.J. and Cretin, Julien and Foster, Nate and Greenberg, Michael and Pierce, Benjamin C.},
  journal    = {SIGPLAN Not.},
  title      = {Matching Lenses: Alignment and View Update},
  year       = {2010},
  issn       = {0362-1340},
  month      = sep,
  number     = {9},
  pages      = {193–204},
  volume     = {45},
  abstract   = {Bidirectional programming languages are a practical approach to the view update problem. Programs in these languages, called lenses, define both a view and an update policy - i.e., every program can be read as a function mapping sources to views as well as one mapping updated views back to updated sources.One thorny issue that has not received sufficient attention in the design of bidirectional languages is alignment. In general, to correctly propagate an update to a view, a lens needs to match up the pieces of the view with the corresponding pieces of the underlying source, even after data has been inserted, deleted, or reordered. However, existing bidirectional languages either support only simple strategies that fail on many examples of practical interest, or else propose specific strategies that are baked deeply into the underlying theory.We propose a general framework of matching lenses that parameterizes lenses over arbitrary heuristics for calculating alignments. We enrich the types of lenses with "chunks" identifying reorderable pieces of the source and view that should be re-aligned after an update, and we formulate behavioral laws that capture essential constraints on the handling of chunks. We develop a core language of matching lenses for strings, together with a set of "alignment combinators" that implement a variety of alignment strategies.},
  address    = {New York, NY, USA},
  doi        = {10.1145/1932681.1863572},
  issue_date = {September 2010},
  keywords   = {boomerang, view update problem, bidirectional languages, lenses, alignment},
  numpages   = {12},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/1932681.1863572},
}

@Article{Foster2007,
  author     = {Foster, J. Nathan and Greenwald, Michael B. and Moore, Jonathan T. and Pierce, Benjamin C. and Schmitt, Alan},
  journal    = {ACM Trans. Program. Lang. Syst.},
  title      = {Combinators for Bidirectional Tree Transformations: A Linguistic Approach to the View-Update Problem},
  year       = {2007},
  issn       = {0164-0925},
  month      = may,
  number     = {3},
  pages      = {17–es},
  volume     = {29},
  abstract   = {We propose a novel approach to the view-update problem for tree-structured data: a domain-specific programming language in which all expressions denote bidirectional transformations on trees. In one direction, these transformations---dubbed lenses---map a concrete tree into a simplified abstract view; in the other, they map a modified abstract view, together with the original concrete tree, to a correspondingly modified concrete tree. Our design emphasizes both robustness and ease of use, guaranteeing strong well-behavedness and totality properties for well-typed lenses.We begin by identifying a natural space of well-behaved bidirectional transformations over arbitrary structures, studying definedness and continuity in this setting. We then instantiate this semantic framework in the form of a collection of lens combinators that can be assembled to describe bidirectional transformations on trees. These combinators include familiar constructs from functional programming (composition, mapping, projection, conditionals, recursion) together with some novel primitives for manipulating trees (splitting, pruning, merging, etc.). We illustrate the expressiveness of these combinators by developing a number of bidirectional list-processing transformations as derived forms. An extended example shows how our combinators can be used to define a lens that translates between a native HTML representation of browser bookmarks and a generic abstract bookmark format.},
  address    = {New York, NY, USA},
  doi        = {10.1145/1232420.1232424},
  issue_date = {May 2007},
  keywords   = {XML, Bidirectional programming, Harmony, view update problem, lenses},
  numpages   = {65},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/1232420.1232424},
}

@Article{Fuxman2006,
  author     = {Fuxman, Ariel and Kolaitis, Phokion G. and Miller, Ren\'{e}e J. and Tan, Wang-Chiew},
  journal    = {ACM Trans. Database Syst.},
  title      = {Peer Data Exchange},
  year       = {2006},
  issn       = {0362-5915},
  month      = dec,
  number     = {4},
  pages      = {1454–1498},
  volume     = {31},
  abstract   = {In this article, we introduce and study a framework, called peer data exchange, for sharing and exchanging data between peers. This framework is a special case of a full-fledged peer data management system and a generalization of data exchange between a source schema and a target schema. The motivation behind peer data exchange is to model authority relationships between peers, where a source peer may contribute data to a target peer, specified using source-to-target constraints, and a target peer may use target-to-source constraints to restrict the data it is willing to receive, but cannot modify the data of the source peer.A fundamental algorithmic problem in this framework is that of deciding the existence of a solution: given a source instance and a target instance for a fixed peer data exchange setting, can the target instance be augmented in such a way that the source instance and the augmented target instance satisfy all constraints of the setting? We investigate the computational complexity of the problem for peer data exchange settings in which the constraints are given by tuple generating dependencies. We show that this problem is always in NP, and that it can be NP-complete even for “acyclic” peer data exchange settings. We also show that the data complexity of the certain answers of target conjunctive queries is in coNP, and that it can be coNP-complete even for “acyclic” peer data exchange settings.After this, we explore the boundary between tractability and intractability for deciding the existence of a solution and for computing the certain answers of target conjunctive queries. To this effect, we identify broad syntactic conditions on the constraints between the peers under which the existence-of-solutions problem is solvable in polynomial time. We also identify syntactic conditions between peer data exchange settings and target conjunctive queries that yield polynomial-time algorithms for computing the certain answers. For both problems, these syntactic conditions turn out to be tight, in the sense that minimal relaxations of them lead to intractability. Finally, we introduce the concept of a universal basis of solutions in peer data exchange and explore its properties.},
  address    = {New York, NY, USA},
  doi        = {10.1145/1189769.1189778},
  issue_date = {December 2006},
  keywords   = {schema mapping, Data exchange, conjunctive queries, metadata model management, certain answers, data integration},
  numpages   = {45},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/1189769.1189778},
}

@InProceedings{Bohannon2006,
  author    = {Bohannon, Aaron and Pierce, Benjamin C. and Vaughan, Jeffrey A.},
  booktitle = {Proceedings of the Twenty-Fifth ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems},
  title     = {Relational Lenses: A Language for Updatable Views},
  year      = {2006},
  address   = {New York, NY, USA},
  pages     = {338–347},
  publisher = {Association for Computing Machinery},
  series    = {PODS '06},
  abstract  = {We propose a novel approach to the classical view update problem. The view update problem arises from the fact that modifications to a database view may not correspond uniquely to modifications on the underlying database; we need a means of determining an "update policy" that guides how view updates are reflected in the database. Our approach is to define a bi-directional query language, in which every expression can be read bot(from left to right) as a view definition and (from right to left) as an update policy. The primitives of this language are based on standard relational operators. Its type system, which includes record-level predicates and functional dependencies, plays a crucial role in guaranteeing that update policies are well-behaved, in a precise sense, and that they are total—i.e., able to handle arbitrary changes to the view.},
  doi       = {10.1145/1142351.1142399},
  isbn      = {1595933182},
  keywords  = {lenses, view update},
  location  = {Chicago, IL, USA},
  numpages  = {10},
  url       = {https://doi.org/10.1145/1142351.1142399},
}

@Comment{jabref-meta: databaseType:bibtex;}
